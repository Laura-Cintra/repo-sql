-- 1. Criar uma procedure que deve receber o código de um cliente e a partir deste dado imprimir o seu nome e e-mail. Os dados deverão ser obtidos a partir das seguintes 
--    colunas (Cod_CLI, NOME_CLI, EMAIL_CLI).
-- OBS: É necessário criar a tabela Cliente e fazer o insert.

SET SERVEROUTPUT ON;

CREATE TABLE tbl_cliente (
    cod_cli   INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nome_cli  VARCHAR(50) NOT NULL,
    email_cli VARCHAR(50) NOT NULL
);

INSERT INTO tbl_cliente (cod_cli, nome_cli, email_cli)
VALUES (1, 'João Silva', 'joao.silva@email.com');

INSERT INTO tbl_cliente (cod_cli, nome_cli, email_cli)
VALUES (2, 'Maria Oliveira', 'maria.oliveira@email.com');

CREATE OR REPLACE PROCEDURE proc_relatorio_cliente(
    p_cod NUMBER
) AS 
    v_nome  VARCHAR2(50);
    v_email VARCHAR2(50);
BEGIN
    SELECT nome_cli, email_cli 
    INTO v_nome, v_email
    FROM tbl_cliente 
    WHERE cod_cli = p_cod;
    
    dbms_output.put_line('Código Cliente: ' || p_cod);
    dbms_output.put_line('Nome Cliente: ' || v_nome);
    dbms_output.put_line('Email Cliente: ' || v_email);
END;

CALL proc_relatorio_cliente(1);

CREATE OR REPLACE PROCEDURE BuscaCliente(
    p_cod NUMBER
) IS 
    v_cliente tbl_cliente%ROWTYPE;
BEGIN
    SELECT * INTO v_cliente
    FROM tbl_cliente 
    WHERE cod_cli = p_cod;
    
    dbms_output.put_line('Código Cliente: ' || p_cod);
    dbms_output.put_line('Nome Cliente: ' || v_cliente.nome_cli);
    dbms_output.put_line('Email Cliente: ' || v_cliente.email_cli);
END;

CALL BuscaCliente(1);

-- 2. Criar uma proc que receberá um RA, um nome e 4 notas conforme a sequência: (RA, NOME, A1, A2, A3, A4).
-- A partir destes valores deverá efetuar o cálculo da média somando o maior valor entre A1 e A2 as notas A3 e A4 e dividindo o valor obtido por 3 (achando a média).
-- Se a média for menor que 6 o aluno estará REPROVADO e se a média for igual ou superior a 6 o aluno estará APROVADO.
-- A procedure deverá inserir os valores acima em uma tabela denominada ALUNO com as seguintes colunas: RA, NOME, A1, A2, A3, A4, MEDIA, RESULTADO.

CREATE TABLE tbl_aluno (
    ra        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nome      VARCHAR2(50) NOT NULL,
    a1        NUMBER NOT NULL,
    a2        NUMBER NOT NULL,
    a3        NUMBER NOT NULL,
    a4        NUMBER NOT NULL,
    media     NUMBER(5, 2),
    resultado VARCHAR2(20)
);

CREATE OR REPLACE PROCEDURE proc_inserir_aluno(
    p_ra    NUMBER,
    p_nome  VARCHAR2,
    p_a1    NUMBER,
    p_a2    NUMBER,
    p_a3    NUMBER,
    p_a4    NUMBER
) IS 
    v_media NUMBER(5,2);
    v_resultado VARCHAR2(20);
BEGIN
    v_media := (GREATEST(p_a1, p_a2) + p_a3 + p_a4) / 3;

    IF v_media >= 6 THEN
        v_resultado := 'APROVADO';
    ELSE
        v_resultado := 'REPROVADO';
    END IF;

    INSERT INTO tbl_aluno (ra, nome, a1, a2, a3, a4, media, resultado)
    VALUES (p_ra, p_nome, p_a1, p_a2, p_a3, p_a4, v_media, v_resultado);
    COMMIT;
    
    dbms_output.put_line('RA: ' || p_ra);
    dbms_output.put_line('Nome: ' || p_nome);
    dbms_output.put_line('Média: ' || v_media);
    dbms_output.put_line('Resultado: ' || v_resultado);
END;

CALL proc_inserir_aluno(12347, 'Carlos Pereira', 7, 6, 5, 8);

/*
v_maior_nota NUMBER;

IF p_a1 > p_a2 THEN
        v_maior_nota := p_a1;
    ELSE
        v_maior_nota := p_a2;
    END IF;
*/

-- 3. Criar uma função que deverá receber um número inteiro e retornar se o mesmo é primo ou não
-- LEMBRETE: Números primos são divisíveis somente por eles mesmos e por um